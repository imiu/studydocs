*******************************************************************************
***                     The JavaScript Programming Language                 ***
***                 Based on Douglas Crockford talk in Yahoo 2007           ***
*******************************************************************************
The world most misunderstood programming language =)
    The name (Java as a prefix and Script as a suffix)
    
** The history of JavaScript ** 
1992
    Oak, Gosling as Sun & FirstPerson
    C++ ++ has to be name of Java
1995
    HotJava
    LiveScript, Eich at Netscape
    LiveScript was renamed to JavaScript for alliance of Netscape & Sun
1996
    JScript at Microsoft
    

** Key Ideas **
    Load and go delivery
        Text execution
    Loose typing
    Objects as general containers
    Prototypal inheritance
    Lambda
    Linkage though global variables

** Values Types **
    Numbers
    Strings
    Booleans
    Objects
    null
    undefined

* Numbers *
Only one number type 64-bit floating point aka IEE-754 aka Double

Special number: Not a Number (NaN)
NaN != NaN
typeof NaN == Number

Number(value) to convert text to number. The +

parseInt(value, 10) the radix must be presented, or 08 will became an octal, and 8 is not a digit value in octal, so parseInt("08") === 0

Math object was copied from Java
abs, floor, log, max, pow, random, round, sin, sqrt

* Strings *
Strings in JavaScript are sequence of 0 or more 16-bit characters
It's UCS-2, not quite UTF-16
Strings are !immutable!
String(value) converts to a string
String methods
    charAt, concat, indexOf, lastIndexOf, match, replace, search, slice, split, substring, toLowerCase, toUpperCase

Boolean are true and false
Boolean(value)

null is null

undefined is something else

Falsy values
    false, null, undefined, "", 0, NaN
Truethy values
    all the others including "0" and "false"

Everything else is an Object

* Dynamic Objects *
    Unification of Object and Hashtable
    new Object() produces an empty container of name/value pairs
    A name can be every string, a value can be any value except undefined
    Members can be accessed with dot notaion or subscript notation
    No hash nature is visible (no hash codes or rehash methods)
        In JScript they got a LinkedList and not a hashTable

Loosely Typed but not !untyped!

+ is used for addition and concatenation
    if both operands are number
        then
            add them
        else
            convert and concatenate
            '$' + 3 + 4 = '$34'
            3 + 4 + '$' = '7$'
    also +"42" = 42, like Number("42") and parseInt("42", 10)
    +"3" + (+"4") = 7

&& is tricky
    if first operand is truthy
        then result is second operand
        else result is first operand
    if (a) {
        return a.member;
    } else {
        return a;
    }
    can be rewritten as return a && a.member

|| is tricky too =)
    if the first operand is truthy
        then result is the first operand
        else result is second operand
    So we can fill in default values
        var last = input || default_input;

Bitwise is tricky =)
    for ^ & << >> we convert our 64-bit int to 32-bit and then convert it back

** Expressions **
Statements can have labels (it's soooo not a GoTo)
    loop: for  (;;) {
        if () {
            break loop;
        }
    }

Iterate through object members
    for (var name in object) {
        if (object.hasOwnProperty(name)) { // Not to go up to prototype chain
            // name is a key of current member
            // object[name] is the current value
        }
    }

In switch statement case values can be expressions

** Exception **
    Error, EvalError, RangeError, SyntaxError, TypeError, URIError
throw new Error(reason);
throw {
    name: exceptionName,
    message: reason
}

try {
    ...
} catch(e) { // We have only one catch close, cause we don't have classes
    switch (e.name) {
        case 'Error':
            ...
            break;
        default:
            throw e;
    }
}

Functions always return values. If it's not set to return anything it will return "undefined". And this
    function tst() { return; } is equal to function tst() {}
Only Constructors are exception. They return objects

Objects are actually a Collection

Reserved word can't be a name for a property
    object['goto'] will be good, while object.goto will fail

With a object(o) we can make an inheritance (actually you can't)
    var myNewObject = object(myOldObject) ? o_O Doesn't work at all.

Objects are always pass by reference

Arrays has length, that is 1 larger than the highest integer subscript. They are actually an object, but with some special methods =)

Arrays have methods
    concat, join, pop, push, slice, sort, splice

Don't use
    delete array['a'] // it creates holes
    splice(array['a'], 1) // it doesn't

How to distinguish an array
    value.constructor === Array
    value instanceof Array

Don't use arrays as prototypes
    The object will not have an array nature. And it will not have a lenght!
What's better is just to augment one of your arrays and apply a method to it
Or just augment the Array prototype


Functions are first-class objects
    they can be passed, returned and stored just like any other value
    they can inherit from Object and can store name/value pairs

Lambda
    What JavaScript calls "function", other languages calls Lambda

Scope
    An inner function has access to variables and parameters of functions that it is contained within
    That is known as Static Scoping or Lexical Scoping

Closure
    The scope that an inner function enjoys continues even after the parent functions have returned

Function invocation
    If function is called with too many arguments they are ignored
    If too few arguments, the other will be undefined
    No type checing

arguments
    When the function is called it has additional parameter called arguments
    It contains all the arguments that were passed to the function
    arguments.lenght is a number of parameters passed to the function
    But it's not an !array!

Augmenting built-in types
    Object.prototype, Array.prototype, Function.prototype, Number.prototype ...

typeof
    typeof object (function, number, string, boolean) == 'object' ('function', 'number', 'string', 'boolean')
    typeof array == 'object'
    typeof null == 'object'
    typeof undefined == 'undefined'

function object(o) {
    function F() {};
    F.prototype = o;
    return new F();
}
