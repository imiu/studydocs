***************************
*** Google Python Class ***
***************************
In python we always got deep comparison

Parenthesis are not required in test statements!

String are immutable!

* Slices *
a[5:] from the fifth
a[:5] to the fifth
a[-1:] last symbol
a[:-1] except last

* Copy vs Name *
We copy ints, strings and tuples by default
We got a link for dictionaries and lists

* Files *
f = open(filename)
f.read()            # Read the entire file into string
f.readlines()       # Read the entire file into list
for line in f:      # Iterate through a file
    print line      # by one line

####################################################
### Some citations from "Code like a Pythonista" ###
####################################################
* Dictionaries *
for key in d: print key                 # !"for" loop goes through keys here!
!!! But !!!
for key in d.keys(): d[str(key)]        # To modify dict, use d.keys()
if key in d:                            # if goes through keys too!

!!! Standard stuff !!!
for (book, book_cnt) in data:
    book_dict[book] = book_dict.get(book, 0) + cnt

## Same stuff for more complicated structure ##
for book, book_name in data:
    book_dict.setdefault(book, []).append(book_name) #
# The only caveat here is that the default value is evaluated every time.
# setdefault means "Set if necessary and then get"

# If our key is hard to compute and we don't like it to be evaluated every time...#

## Build dict from to lists. One for keys, one for values ##
d = dict(zip(keys, values))
# The "zip" by itself produces a list of tuples
zip(('a', 'b'), ('x', 'y')) => [('a', 'x'), ('b', 'y')]

## In loops for creating an index for list ##
for (index, item) in enumerate(items):
    print index, item

## List comprehensions ##
[n ** 2 for n in range(10)]                 ## Squares of 0-9
[n ** 2 for n in range(10) if n % 2]        ## Squares of odd 0-9

## Generator Expressions ##
sum(num * num for num in xrange(1, 101))    ## Sum square numbers to 100
# Generator expressions are not greedy, like list comprehensions. That means, that they are lazy and compute the value only if needed. So our memory usage will be rather constant.
####################################################

** Regular Expressions **
re.search(pat, text)        # returns an match object if succeed
match.group(1)              # left-most parenthesis

re.findall(pat, text)       # returns a list of matches

** Os and Sys **
os                          # os specific
shutil                      # shell funcitons
commands                    # execute system commands