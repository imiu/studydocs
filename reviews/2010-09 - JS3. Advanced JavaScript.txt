*******************************************************************************
***                             Advanced JavaScript                         ***
***                Based on Douglas Crockford talk in Yahoo 2006            ***
*******************************************************************************
** Inheritance **
Two Schools
    Classical
    Prototypal (only JavaScript)

Prototypal Inheritance
    Class-free
    Objects inherits from objects
    Secret link to prototype

    Object.prototype is the end of chain

    * Example of Prototypal Inheritance *
    var oldObject = {
        firstM: function () {},
        seconM: function () {}
    };
    var newObject = object(oldObject);
    newObject.thirdM = function () {};
    var myLastOne = object(newObject);
    myLastOne.firstM(); 

Pseudo-Classical Inheritance
    Constructor functions
    The "new" operator
    The prototype member of functions
    
    * Example of Pseudo-Classical Inheritance *
    // ! Creating a class !
    function Constructor() {
        this.member = initializer;
        return this; // optional
    }
    Constructor.prototype.firstM = function (a, b) {};
    Constructor.prototype.seconM = function (a, b) {};
    var newObject = new Constructor();
    // ! Do our Inheritance Magic !
    Constructor.prototype = new BasicConstructor();

Constructor
    When functions are designed to be used with new, they are called constructors.

If omit a "new" keyword, we'll receive a global object.

Function's prototype member is an object containing a constructor member which is a reference to the function object.

A syntactic sugar to make it a little more classical 
    Function.prototype.method = function (name, func) {
        this.prototype[name] = func;
        return this;
    }

    Constructor.
        method('first', function (a, b) {...}).
        method('second', function (c) {...});

PseudoClassical Inheritance once again
    function BiggerConstructor() {};
    BiggerConstructor.prototype = new MyConstructor();

But the object function is more convenient way to do inheritance.

We can create singleton with just an object literal.

In JavaScript we have only functions, but we can create with them anything:
    Functions
    Methods
    Constructors
    Classes
    Modules

Module is actually used for a namespace and no leaks outside the module.

And we must use modules, not to pollute the global space.

If we want a singleton with public/private stuff, we use a module pattern

    var singleton = function () {
        var privateVar;
        function privateFun() {...}
        
        return {
            publicFun: function (a, b) {
                privateFun();   // accessible
                privateVar;     // accessible, and we don't need this.privateVar
            }
        }
    }();

This will work due to a closure support. And applications are actually singletons.

* Power Constructor *
    1. Make a new object somehow
    2. Augment it
    3. Return it

    function powerConstructor() {
        var that = object(oldObject), 
                   privateVariable;
        function privateFunction(x) {}
        
        that.firstMethod = function (a, b) { privateVariable; }
        that.secondMethod = function (c) { privateMethod(); }
        return that;
    }

* Parasitic Inheritance *
    // Basic power constructor, factory actually
    function gizmo(id) {
        return {
            id: id,
            toString: function () {
                return "gizmo " + this.id
            }
        }
    }
    
    // Power constructor, that inherits from gizmo
    function hoozit(id) {
        // here goes magic, we receive our object in that...
        var that = gizmo(id);
        // ... modify it...
        that.test = function (testid) {
            return testid === this.id
        }
        // ... and return
        return that;
    }
    // And we don't have any parasitic objects. It's one object really that is
    // transformed through the constructors

* Inheritance Patterns *
    *Prototypal Inheritance* works really well with public methods.
    *Parasitic Inheritance* works really well with privileged and private and public methods.
    *Pseudoclassical Inheritance* for elderly programmers who are old and set in their ways =)

