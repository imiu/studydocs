*******************************************************************************
***                 An Inconvenient API: The Theory of the DOM              ***
***                Based on Douglas Crockford talk in Yahoo 2006            ***
*******************************************************************************

"Dynamic HTML" was buzzword invented by Microsoft

Ajax was coined by Jesse James Garrett

If you use <script src="..."></script>, then "type" attribute is ignored. So there is absolutely no need to write
<script src="..." type="application/javascript"></script>

Placing recommendations
    css to the top
    js to the bottom
    minify and gzip files
    reduce number of scripts

document.write is highly not recommended
    if called before onload, it will write to document
    if called after, it will overwrite the document

* Traversing *
document.getElementById(id)
document.getElementByName(name)
node.getElementyByTagName(tag_name)

A node name or a tag name returned to you can be uppercased.

Each node has 4 or 5 pointers:
    parentNode
    firstChild
    lastChild
    nextSibling
    previousSibling

But if we want some traversing, we just recursively visit every element using firstChild and nextSibling pointers. It's soooo like binary tree.
    function walkTheDom(node, func) {
        func(node); // our function that does work with a node
        node = node.firstChild;
        while (node) {
            walkTheDom(node, func);
            node = node.nextSibling;
        }
    }

"className" is called so, just because "class" is a reserved word in JavaScript

* Manipulating *
Old School
    my_image.src = new_url;
New School
    my_image.getAttribute('src');
    my_image.setAttribute('src', new_url)

document.createElement(tagName)
document.createTextNode(text)
node.cloneNode()        // Clone only THE node
node.cloneNode(true)    // Clone node and it's children

node.appendChild(new)
node.insertBefore(new, sibling)
node.replaceChild(new, old)
node.removeChild(old)
    !! Remove all the event handlers from the node before removing it !!

innerHTML (created by Microsoft) are available in all modern browser

* Events *
Events were introduced in Netscape 2

3 events adding techniques:
    Classic
        node['on' + type] = f;
    Microsoft
        node.attachEvent('on' + type, f);
    W3C
        node.addEventListener(type, f, false);
        //This "false" is obliged, it shows we wanna bubbling, not trickling.

Event Handler Boilerplate
    function (e) {
        // e is not passed by MS, it uses a global event variable
        e = e || event;
        // some browsers use target, other use srcElement
        var target = e.target || e.srcElement;
    }

2 Schools of event handling (Trickling and Bubbling)
    Trickling is abandoned. It was in Netscape 4. It was top down model.
    Bubbling (by Microsoft) is a modern one.

Bubbling doesn't stop when event is handled! We must explicitly call e.stopPropagation()

To prevent a default action return false from event handler.

* Memory Leaks *
It's IE6 which is the reason why we must remove event handlers from nodes before deleting or replacing them. And even before you clean out the innerHTML property.

* DOM Creatures in JavaScript *
alert, confirm, prompt
    those functions block the browser thread, i.e. they stop evaluation of anything
setTimeout, setInterval

* Window object *
Don't use "self", cause sometimes it points to window object! (o_O)

* Browser detection *
Firefox lies it's Mozilla/5
Opera 9 lies it's Opera/9
Safari 2 lies it's Mozilla/5
IE6 lies it's Mozilla/4 (IE1 said told the truth, but many server did not send him pages, complaining he is not a Mozilla, so in IE1.5 they lied they Mozilla)

Use feature detection instead to determine a browser.
