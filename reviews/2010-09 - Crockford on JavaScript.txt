*******************************************************************************
***                         Crockford on JavaScript                         ***
***                        Based on YUI Theater talk                        ***
*******************************************************************************

*********************************
*** Volume 1. The Early Years ***
*********************************
80-character limit comes from a punch card.

Mainframes spoiled into commercial after WWII, when they were used for cryptography, weapon creation etc.

Carriage Return and Linfefeed (cr/lf) are created to imitate teletype. Systems that are more hardware-oriented chosed lf, and system that are more user-oriented chosed cr.

Hight-level computer languages were thought as a automatic program languages, but they just rose the level of abstraction.

Simula was a first object-oriented language. It origins from Algol.
Smalltalk was designed as a language for kids in Xerox PARC. It was a first truly object-oriented language.
Smalltalk doesn't invoke a method, it sends a message.
Basically all the modern language mix concepts of Smalltalk with syntax of C.

Another less known branch of Smalltalk was a language called "Self", which took Smalltalk ideas and throw away classes. So objects could inherit from objects. It was developed in Xerox PARC and moved to Sun Labs.

The Actor Model was born from Smalltalk too. The idea of sending a message can help to build robust, scalable and secure systems.
LISP was an AI language.
The Actor Model + LISP = Scheme

Our events like onmouseup came from HyperCards (invented by Bill Atkinson), language that Apple invented for non-programmers to program. It had a script language called HyperTalk, that should be like an english.

The reason why Mosaic got everyone's attention, was an image tag.
Netscape and Spyglass (Internet Explorer) were born from Mosaic web browser.

Netscape wanted HyperCard with it's event model to be in browsers. But the guy, who was hired to do it wanted a Scheme interpreter. But they told him, that Scheme is too wired, so he must take the ideas of Scheme and make it like Java. In a couple of weeks.

Java(Syntax) + Scheme(Function model) + Self(Prototypal objects) => JavaScript

Just about that time Java (that primary idea was to be a language for web) failed.


******************************************
*** Chapter 2. And Then Was JavaScript ***
******************************************
Originally JavaScript was a LiveScript

MicroSoft reverse engineered JavaScript and called it JScript.

And then Netscape went to W3C to make a standard from JavaScript. And W3C hated Netscape, cause they didn't implement the standards and so W3C told Netscape to go to hell. That's why they went to ECMA (European Computer Manufacturers Association).
And the name ECMAScript came out from the fact, that Sun had a license for a name "JavaScript" and Netscape had a personal single license to call it JavaScript. So only Netscape could call it that way.

1999 Third Edition  -   ES3
2009 Fifth Edition  -   ES5
    - Default
    - Strict
For the short term, we have to use ES3. But in a long term perspective we should stick to ES5/Strict. And ES5/Default shouldn't be use at all.

Where do Bad Parts come from
    Legacy
    Good Intensions
    Haste
But the bad parts can be avoided.

An object is a dynamic collection of properties.
    Every property has a key string that is unique within that object.

Basic get/set/delete operations
    object.prop / object.prop = 'some' / delete object.prop

Two kinds of properties
    Data properties
    Accessor properties

* Data property *
A property is a named collection of attributes:
    value:          any JS value
    writable:       boolean
    enumerable:     boolean                             was in ES3, usable ES5
    configurable:   boolean                             was in ES3, usable ES5
    get:            function () { ... return value; }   ES5
    set:            function (value) { ... }            ES5

Object literals, as they are in ES5
Short form:
    var my_object = {foo: bar};
Full form:
    var my_object = Object.defineProperties(Object.create(Object.prototype), {
        foo: {
            value: bar,
            writable: true,
            enumerable: true,
            configurable: true
        }
    });

* Accessor property *
Object.defineProperty(my_object, 'inch', {
    get: function () {
        return this.mm / 25.4;
    },
    set: function () {
        this.mm = value * 25.4;
    },
    enumerable: true
});
my_object.inch // use a get method
my_object.inch = 3 // use a set method

* Classes vs Prototypes *
Working with objects is really easy
    Make an object
    Create a new object, that inherits from that object
    Customize new object
It's all about "differential inheritance". You change only things, that need to be changed after the inheritance.

Objects have a prototype attribute
    prototype: object or null
    Object.create(object, properties ...)       ES5
    Object.getPrototypeOf(object)               ES5

Instead of Object.create we had a "new" operator, which we can represent like
    function new(func, arguments) {
        var that = Object.create(func.prototype),
            result = func.apply(that, arguments);
        return (typeof result === 'object' && result) || that;
    }

If you use the "new" function and omit it on object creation, you stuck with global object. And there is no compiler or runtime error.

While writing a word counter we can introduce a very ugly bug...
    function bump_coun(word) {
        if (word_count[word]) {
            word_count[word] += 1;
        } else {
            word_count[word] = 1;
        }
    }
And if we meet a word 'constructor' in our text we're stuck. Cause the "word_count['constructor']" will evaluate to "true", cause 'constructor' is a property of our object. So the right way will be:
    if (typeof word_count[word] === 'number')

When cycling through the object properties, be sure, you not deal with prototype methods:
    for (name in object) {
        if (object.hasOwnProperty(name)) {
            ...
        }
    }
But that will fail, if we got a 'hasOwnProperty' property for our object. So the correct and awful way to write it will be:
    for (name in object) {
        if (Object.prototype.hasOwnProperty.call(object, name)) {
            ...
        }
    }

* And here comes ES5 *
Object.create(null) creates an object, that inherits nothing
Set enumerable attribute to false, to prevent them in for loops
Object.keys(object) produces an array with strings with OWN properties

Objects have an extensible attribute
    extensible: boolean                 // 
    Object.isExtensible(object)         // boolean
    Object.preventExtensions(object)    // prevent extensions
    Object.seal(object)                 // prevent from changing something
    Object.freeze(object)               // setting to readonly

** Let's talk about types **
Every type is inherited from Object
* Numbers *
typeof Number.prototype === 'object'
Only on number type
    64-bit floating point aka Double (back in Fortran "double precision")
Integers under 9 007 199 254 740 992 (nine quadrillion) are perfectly ok
    9007199254740992 === 9007199254740992 + 1
    a = 0.1; b = 0.2; c = 0.3
    (a + b) + c !== a + (b + c)
The only way to count decimal is to use integers, so multiply, Luke.

Numbers methods
    isExponential
    toFixed
    toLocaleString
    toPrecision
    toString
    valueOf             // used by the system itself

Augmentation of Number is that easy:
    if (!Number.prototype.trunc) {
        Number.prototype.trunc = function trunc(number) {
            return Math[number >= 0 ? 'floor' : 'ceil'](number);
        }
    }

Numbers are first class objects
    can be stored in a variable
    can be passed as a parameter
    can be returned from a function
    can be stored in an object

And we got a Math object, which contains all the math functions and constants.

And we got NaN. Like from 10/0 == NaN
    NaN === NaN is FALSE
    NaN !== NaN is TRUE

* String *
A sequence of 0 or more 16-bit Unicode characters
    UCS-2, not quite UTF-16
    No awareness of surrogate pairs
    Strings are immutable (frozen)
    
On converting Numbers to Strings
    str = num.toString();       // fails (throw exception) on null and undefined
    str = String(num);          // produces 'null' and 'undefined' on them

On converting Strings to Numbers
    num = Number(str);
    num = +str;                 // same thing, but smaller =)
    num = parseInt(str, 10);    // a strange one
        parseInt("12em")        // 12
        parseInt("08")          // 0 (because it thinks we are at base8)
        parseInt("08", 10)      // 8

String.length
    Number of 16-bit character in a string

New string methods in ES5
    trim

* Array *
Array inherits from Object
Indexes are converted to strings and used as names for retrieving values
So every call to arr[5] is a hash lookup

But they are different from objects, cause they have a special length property
It's always 1 larger than the highest integer subscript
Don't use for...in with arrays, it doesn't guarantee what order it will provide

Add new item to array is just
    my_list[my_list.length] = 'new item';

New array methods in ES5
    forEach, map, reduce, filter, indexOf, every, some, reduceRight, lastIndexOf

And we got a very strange .sort method. It sorts naturally:
    [1, 2, 3, 11, 21].sort()    // [1, 11, 2, 21, 3]
    a = [1, 2, 3, 11, 21].sort(
    function(a, b){
        return a - b
    });                         // [1, 2, 3, 11, 21]

We can use delete, but leaves a hole (with undefined), so we use splice(n, 1)
But it's slow. Cause we have to rehash all the keys

* null and undefined *
typeof null         == 'object'
typeof array        == 'object'
typeof null         =='object'
typeof undefined    == 'undefined' // bug copied by Microsoft

Falsy values
    false, null, undefined, "", 0, NaN
Truthy values
    all the others, including "0" and "false", including empty objects and arrays

Objects are always passed by reference
    the === operator returns true only if operands are the same object

We could use "+" operator to be sure that we work with numbers

* Famous true-false table. Transitivity doesn't work at all *
'' == '0'           // false
0 == ''             // true
0 == '0'            // true

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true

' \t\r\n ' == 0     // true

* && and || and !!*
&&
    If first is truthy, return second, else return first
||
    If first is truthy, return first, else return second

!!
    Makes booleans, so
        !!'true' === true
        !!'' === false

Bitwise operators a really slow, cause we convert from 64-bit int to signed 32-bit int, do our magic and convert back. Multiply is faster, than shift.

* Statements *
We got a label for loop statements, so we can break the loops
    loop_label: for( ;; ) {
        if ( ... ) {
            break loop_label;
        }
    }

Exception is easy
    throw new Error(reason);
    throw {name: exceptionName, message: reason};

Catch is easy too
    try {
        ...
    } catch (e) {
        switch (e.name) {
            case 'Error':
                ...
                break;
            default:
                throw e;
        }
    }
Types of exception: Error, EvalError, RangeError, SyntaxError, TypeError, URIError

"with" statement will be cleaned out from ES5


**************************************
*** Act III. Function the Ultimate ***
**************************************
We got functions for all
    Method
    Class
    Constructor
    Module

Function expression produces the instance of a function object.
Functions objects are first class.
    may be passed as an argument
    may be returned from a function
    may be assigned to a variable
    may be stored in an object or array
They inherit from Function.prototype

When we write:
    var my_var = 0;
it expands to:
    var my_var = undefined; // goes to the top of a function
    my_var = 0;             // wherever we define it

Function expressions vs Function statements
    statements are older and now just a shorthand for expressions
    so when we write
        function foo() {}
    we got:
        var foo = function foo() {};
    and it goes just like with definings:
        var foo = undefined;
        foo = function foo() {}

But we still got some issues with function order:
    foo();
    foo = function() {
        console.log('bar');
    };
    foo();
    function foo() {            // foo = function foo() {   //
        console.log('foo');     //   console.log('foo');    // This is similar
    }                           // }                        //
It happens because with unnamed function var statement our function declaration is split and the "var foo = undefined" goes to the top, and "foo = function(){}" stays where it is declared. While with "var foo = function foo(){}" both part are go to the top.

To prevent scope confusing
    declare all variables at the top of the function
    declare all functions before you call them

Every function returns a value
    simple functions return undefined, if nothing else is mentioned
    constructors will return value of "this"

Two pseudo parameters "this" and "arguments"
"arguments" is a array-like object, it has length 
    don't mess with an arguments array, take it as a read-only stuff
It is a real array (inherited from array) in ES5

"this" contains a reference to the object of invocation

Invocation
    Method form
        Obj.methodName(arguments)
        Obj["methodName"](arguments)
            "this" is set to Obj
    Function form
        funcitonObject(arguments)
            "this" is set to the global object
                (fixed in ES5 ("this" is set to "undefined"))
    Constructor form
        new FunctionValue(arguments)
            "this" is set to newly created object
    Apply form
        functionObject.apply(thisObject, arguments)
        functionObject.call(thisObject, argument)
            We explicitly specify what is "this" (here it will be thisObject)
            "apply" takes array of arguments
            "call" takes individual arguments

* Closure *
    Lexical scope
    Static scope
When a context of an inner function includes the scope of the outer function.
This continues even after the outer function has returned.

We need a function that returns a name for a digit.
First we came with this:
    var names = ['zero', 'one', 'two'];
    var digit_names = function (n) {
        return names[n];
    }
It's good, but if someone will come with "names" array, we're out of luck.
So, lets do something else:
    var digit_names = function (n) {
        var names = ['zero', 'one', 'two'];        
        return names[n];
    }
It's better, nobody can spoil our "names" array. But it's slow. Cause every time we call a function, we define the array. And this array can be much bigger.
So let's make some closure:
    var digit_names = (function () {
        var names = ['zero', 'one', 'two'];
        return function (n) {
            return names[n];
        }
    }());
So, this kid will help us. It's a function, that will execute immediately and return us a function, that we need. But the "names" array is bound to this function, and no need to reinitialize it.

And we got a Lazy patterns, that is, in fact, slower, than one with an array
    var digit_names = function (n) {
        var names = ['zero', 'one', 'two'];
        digit_names = function (n) {
            return names[n];
        }
        return digit_names(n);
    }

** Inheritance **
* Pseudoclassical Inheritance *
    function Gizmo(id) {
        this.id = id;
    }
    Gizmo.prototype.toString = function () {
        return "gizmo " + this.id;
    }
    
    function Hoozit(id) {
        this.id = id;
    }
    Hoozit.prototype = new Gizmo();
    Hoozit.prototype.test = function (id) {
        return this.id === id;
    }

* Prototypal Inheritance *
    // It's just the same stuff as Pseudoclassical, but more pleasant looking
    var gizmo = new_constructor(Object, function (id) {
        this.id = id;
    }, {
        toString: function () {
            return "gizmo " + this.id;
        }
    });
    
    var hoozit = new_constructor(gizmo, function (id) {
        this.id = id;
    }, {
        test: function (id) {
            return this.id === id;
        }
    });
    
    // And here goes new_constructor function, it's totally ES5
    function new_constructor(extend, initializer, methods) {
        var func, prototype = Object.create(extend && extend.prototype);
        if (methods) {
            methods.keys().forEach(function (key) {
                prototype[key] = methods[key];
            });
        }
        func = function () {
            var that = Object.create(prototype);
            if (typeof initializer === 'function') {
                initializer.apply(that, arguments);
            }
            return that;
        }
        func.prototype = prototype;
        prototype.constructor = func;
        return func;
        }
    }

* Module Pattern *
    var singleton = (function () {
        var privateVariable;                    // This is 
        function privateFunction(x) {           // the shared state
            ...privateVariable...               // for all methods
        }                                       // and variables
        return {
            firstMethod: function (a, b) {
                ...privateVariable              // Private accessible through
            },                                  // closure
            secondMethod: function (c) {
                ...privateFunction              // Private accessible through
            }                                   // closure
        };
    }());                                       // Call immediately

    // Variation of a pattern with a global variable
    (function () {                              // The wrapper parenthesis
        var privateVariable;                    // are required here
        function privateFunction(x) {           // cause we want it to be a
            ...privateVariable...               // function expression
        }                                       // to execute immediately.
        GLOBAL.firstMethod = function (a, b) {
            ...privateVariable...
        };
        GLOBAL.secondMethod = function (c) {
            ...privateFunction()...
        };
    }());

* Power Constructors *
    1. Make an object
        Object literal, new, Object.create, call another power constructor
    2. Define some variables and functions
        These become private members
    3. Augment the object with privileged methods
    4. Return the object

    function myPowerConstructor(x) {
        var that = otherMaker(x);               // 1. Create an object
        var secret = f(x);                      // 2. Define variables
        that.priv = functoin () {               // 3. Augment the object
            ...secret x that...
        };
        return that;                            // 4. Return the object
    }

    // Let's rewrite our Classical Inheritance to Functional Inheritance
    function gizmo(id) {
        return {
            id: id,                             // We can throw it away
            toString: function () {
                return "gizmo " + this.id;
            }
        };
    }
    function hoozit(id) {
        var that = gizmo(id);
        that.test = function (testid) {
            return testid === this.id
        };
        return that;
    }
    
Realization of memorizer with JS for recursive functions
    function memorizer(memo, formula) {
        var recur = function (n) {
            var result = memo[n];
            if (typeof result !== 'number') {
                result = formula(recur, n);
                memo[n] = result;
            }
            return result;
        }
        return recur;
    }
    
    var factorial = memorizer([1, 1], function (recur, n) {
        return n * recur(n - 1);
    });
    
    var fibonnacci = memorizer([0, 1], function (recur, n) {
        return recur(n - 1) + recur(n - 2);
    });

Don't declare functions in a loop
    it can be created every time the loop is executed
    they close over the reference to variable, and variable can change


*********************************************
*** Episode IV. The Metamorphosis of Ajax ***
*********************************************
The Metamorphosis of Ajax - is a book by Sir John Harrington. The inventor of flushing toilet. And he called his invention Ajax.

Jessy James Garret from Adaptive Path. He had to make a presentation for managers about new partial refresh of pages. And once in a shower he decided to call it Ajax.

Performance of DOM
    touching a node has a cost
    styling can have a big cost
    reflow can have a big cost
    repaint can have a big cost
    random things like nodelist can have a big cost
In most applications JavaScript has a small cost

Profiling tools
    Speed Tracer (Chrome)
    dynaTrace (IE)


*************************************
*** Part 5. The End of All Things ***
*************************************
We got serious problems with XSS attacks.
And mashups just made it worse.
There are 2 solutions to this problem by now:
    Caja
    ADsafe
But they are partial solutions.

But we got something better. It's ES5 strict mode.
But it doesn't resolve XSS problem ^_^

* Passing by reference *
    variable = {};
    a = variable;
    b = variable;

    a === b;        // true, they are the same variable
More confusion about it
    function funky(o) {
        o = null;
    }
    var x = {};
    funky(x);
    alert(x);       // {}
Funky got a reference to object. Then he replaces "o" from what it was pointed to "null". So the real object is untouched.
And here what really pisses me off:
    function sim(x) {
        x = 2;
    }
    x = 1;
    sim(x);
    console.log(x); // 1
    
    function obj(x) {
        x.a = 2;
    }
    x = {};
    obj(x);
    console.log(x); // x.a = 2

The right way to interact between the functions is a callback.
And we can even do it with objects
    function storer(obj, name) {
        return function (result) {
            obj[name] = result;
        }
    }
    
    do_it(inputs, storer(store_object, 'data_name'));
Or, if we use it a lot, we can make a "storer factory"
    function storer_maker(obj) {
        return function(name) {
            return function (result) {
                obj[name] = result;
            };
        };
    }
    
    current_storer = storer_maker(current_object);  // create a storer function
    do_it(inputs, current_storer('data_name'));     // pass it with a name
And we got a veeery beautiful way to prevent our do_it from storing this function and get in it later, when we don't want it.
    function once(func) {
        return function () {
            var f = func;
            func = null;
            return f.apply(this, arguments);
        };
    }
    
    do_it(inputs, once(storer(current_storer, 'data_name')));

** Performance **
t = c * n
    t - total time
    c - cost per iteration
    n - number of iterations

* The Big O Notation *
    O(1)            Constant
    O(log n)        Logarithmic
    O(n)            Linear
    O(n log n)      Loglinear
    O(n2)           Exponential
    O(n!)           Factorial

In JavaScript arrays have O(log n) or O(n) search.

x++     !==     x += 1
++x     ===     x += 1


************************
*** Scene 6. Loopage ***
************************
Things that block the browser loop
    alert, confirm, prompt
    XHR synchronous

