*******************************************************************************
***                       High Performance JavaScript                       ***
***               Based on various authors talk in Yahoo 2010               ***
*******************************************************************************
** DOM Usage Optimization **
Why DOM is slow?
Cause there's ECMALand and DOMLand, and every time you access the DOM you pay penalty.

So DOM manipulation takes much more, than JS.

Dom changed are queued and after some period of time executed as a bunch.
We can flush the queue by calling computed.style or something like that. In order to provide us with correct numbers, browser will flush the queue. So:
    bodystyle.color = 'red';            // queue
    tmp = computed.backgroundColor;     // flush
    bodystyle.color = 'white';          // queue
    tmp = computed.backgroundColor;     // flush
    
    bodystyle.color = 'red';            // queue
    bodystyle.color = 'white';          // queue
    tmp = computed.backgroundColor;     // flush

* 10 Commandments *
 1. Don't touch the DOM
 2. Cache the DOM references in local vars (2x - 200x faster)
 3. Use selector API
 4. Cache the length when looping collection of DOM elements
 5. Update the DOM offline (take from tree, update, put back)
 6. Batch style changes (don't mix computed and style change)
 7. Don't ask for layout information excessively
 8. Minimize reflow areas
 9. Use event delegation (bubbling, actually)
10. Don't touch the DOM


** Responsive Interfaces **
The UI Thread
    Draw UI updates
    Executing JavaScript
That's why you can't update UI while executing JavaScript and visa versa.
Jobs are being queued.

So if we got a button and an onclick on it, than stack will be:
    Draw a clicked button
    Execute onclick
    Draw an unclicked button
So, long running JavaScript == UI freeze

So when we call setTimeout we say "In 500ms add this job to the queue"

* Runaway Script Timer Limits *
    Internet Explorer: 5 million statements
    Firefox: 10 seconds
    Safari: 5 seconds
    Chrome: Unknown, hooks into normal crash control mechanism
    Opera: none
This timer is based on a single queue job.

And you can split your execution with timers.
    function timedProcessArray(items, process, callback) {
        // Clone the initial items
        var todo = items.concat();
        // Set timeout for 25 ms
        setTimeout(function(){
            // Measure start time
            var start = +new Date();
            // Process our stuff, while it's not ended or time is not ended
            do {
                process(todo.shift());
            } while (todo.length > 0 && (+new Date() - start < 50));
            // If we got something more to do, set timer for execution again
            if (todo.length > 0) {
                setTimeout(arguments.callee, 25);
            } else {
                // If we're done, call a callback
                callback(items);
            }
        }, 25); // Here is 25ms
    }

Web Workers to the rescue!
    // On the page
    // File with our worker javascript code
    var worker = new Worker("code.js");
    // When we receive message from worker, we just alert it
    worker.onmessage = function(event) {
        alert(event.data);
    };
    // We send a message to the worker
    worker.postMessage("Ololo!");

    // In code.js
    // When we receive a message to us
    self.onmessage = function(event) {
        // We just send back some some message with data received
        self.postMessage("Hello, " + event.data + "!");
    }
Web Worker Support
    Firefox 3.5
    Safari 4
    Chrome 4


** Multipart XHR **
If we got a loooooooong list of images to be loaded (user icons, or something else we can't use sprite for) or something like this, we can perform a really interesting stuff.
1. We send a request to the browser with a list of required images.
    /rollup.php?list_of_requested_resourses
2. Server reads files, concats them into one string and sends it back
3. Response is separated into discrete resources.
    split on mime boundary: -blah-2482-8234234
4. Each resource is passed to the listeners registered for that mime-type:
    F.mxhr.listen('image/jpeg', function(payload) {...});

We can use base64 string for images and plain text for js, html, css.

What are the benefits?
    Single HTTP request
    Sprite without sprites
    Pull all resources in one pass (html, css, js, img)

What are the drawbacks?
    Caching actually doesn't work at all
    Doesn't work in IE
        Can't pass base64 images to IE

So, it's a good solution for mobile version of site.


** Building and deploying high performance JavaScript applications **
1. Combine the JavaScript files
2. Minify JavaScript files
3. Serving JavaScript files gzipped
4. Cache JavaScript files
    iPhone has a site limit for a cache, so we must balance http requests and file size (may be serve 2 files, one of them will be cached by iPhone)
    and we can use local storage
5. Use CDN

** Performance Tools **
FireBug profiler has an API, so we can call:
    console.profile();
    // our js code
    console.profileEnd();
    // And to measure the time
    console.time();
    // our js code
    console.timeEnd();